---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Armin.
--- DateTime: 17.06.2018 17:39
---
local AceGUI = LibStub("AceGUI-3.0")
local MethodDungeonTools = MethodDungeonTools
local db
local tonumber,tinsert,slen,pairs,ipairs,tostring,next,type,sformat = tonumber,table.insert,string.len,pairs,ipairs,tostring,next,type,string.format
local UnitName,UnitGUID,UnitCreatureType,UnitHealthMax,UnitLevel = UnitName,UnitGUID,UnitCreatureType,UnitHealthMax,UnitLevel


local function tshow(t, name, indent)
    local cart     -- a container
    local autoref  -- for self references

    --[[ counts the number of elements in a table
    local function tablecount(t)
       local n = 0
       for _, _ in pairs(t) do n = n+1 end
       return n
    end
    ]]
    -- (RiciLake) returns true if the table is empty
    local function isemptytable(t) return next(t) == nil end

    local function basicSerialize (o)
        local so = tostring(o)
        if type(o) == "function" then
            local info = debug.getinfo(o, "S")
            -- info.name is nil because o is not a calling level
            if info.what == "C" then
                return sformat("%q", so .. ", C function")
            else
                -- the information is defined through lines
                return sformat("%q", so .. ", defined in (" ..
                        info.linedefined .. "-" .. info.lastlinedefined ..
                        ")" .. info.source)
            end
        elseif type(o) == "number" or type(o) == "boolean" then
            return so
        else
            return sformat("%q", so)
        end
    end

    local function addtocart (value, name, indent, saved, field)
        indent = indent or ""
        saved = saved or {}
        field = field or name

        cart = cart .. indent .. field

        if type(value) ~= "table" then
            cart = cart .. " = " .. basicSerialize(value) .. ";\n"
        else
            if saved[value] then
                cart = cart .. " = {}; -- " .. saved[value]
                        .. " (self reference)\n"
                autoref = autoref ..  name .. " = " .. saved[value] .. ";\n"
            else
                saved[value] = name
                --if tablecount(value) == 0 then
                if isemptytable(value) then
                    cart = cart .. " = {};\n"
                else
                    cart = cart .. " = {\n"
                    for k, v in pairs(value) do
                        k = basicSerialize(k)
                        local fname = sformat("%s[%s]", name, k)
                        field = sformat("[%s]", k)
                        -- three spaces between levels
                        addtocart(v, fname, indent .. "   ", saved, field)
                    end
                    cart = cart .. indent .. "};\n"
                end
            end
        end
    end

    name = name or "__unnamed__"
    if type(t) ~= "table" then
        return name .. " = " .. basicSerialize(t)
    end
    cart, autoref = "", ""
    addtocart(t, name, indent)
    return cart .. autoref
end

local currentEnemyIdx
local currentCloneGroup
local currentTeeming
local currentPatrol
local currentPatrolfacing1 = 0
local currentPatrolfacing2 = 0
---CreateDevPanel
---Creates the dev panel which contains buttons to add npcs, objects to the map
function MethodDungeonTools:CreateDevPanel(frame)
    db = MethodDungeonTools:GetDB()
    frame.devPanel = AceGUI:Create("TabGroup")
    local devPanel = frame.devPanel
    devPanel:SetTabs({{text="Door", value="tab1"}, {text="Enemy", value="tab2"}})
    devPanel:SetWidth(250)
    devPanel:SetPoint("TOPRIGHT",frame.topPanel,"TOPLEFT",0,0)
    devPanel:SetLayout("Flow")
    devPanel.frame:Hide()

    MethodDungeonTools:FixAceGUIShowHide(devPanel)

    -- function that draws the widgets for the first tab
    local function DrawGroup1(container)
        local option1 = AceGUI:Create("EditBox")
        option1:SetLabel("Target Floor")
        option1:SetText(1)
        local option2 = AceGUI:Create("EditBox")
        option2:SetLabel("Direction 1up -1d 2r -2l")
        option2:SetText(1)
        container:AddChild(option1)
        container:AddChild(option2)

        local buttons = {
            [1] = {
                text="Add Door",
                func=function()
                    if not MethodDungeonTools.mapLinks[db.currentDungeonIdx] then MethodDungeonTools.mapLinks[db.currentDungeonIdx] = {} end
                    if not MethodDungeonTools.mapLinks[db.currentDungeonIdx][MethodDungeonTools:GetCurrentSubLevel()] then
                        MethodDungeonTools.mapLinks[db.currentDungeonIdx][MethodDungeonTools:GetCurrentSubLevel()] = {}
                    end
                    local links = MethodDungeonTools.mapLinks[db.currentDungeonIdx][MethodDungeonTools:GetCurrentSubLevel()]
                    local posx,posy = 300,-200
                    local t = tonumber(option1:GetText())
                    local d = tonumber(option2:GetText())
                    if t and d then
                        tinsert(links,{x=posx,y=posy,target=t,direction=d})
                        MethodDungeonTools:UpdateMapLinks()
                    end
                end,
            },
            [2] = {
                text="Export to LUA",
                func=function()
                    local export = tshow(MethodDungeonTools.mapLinks[db.currentDungeonIdx],"MethodDungeonTools.mapLinks[dungeonIndex]")
                    MethodDungeonTools.main_frame.ExportFrame:Show()
                    MethodDungeonTools.main_frame.ExportFrame:SetPoint("CENTER",MethodDungeonTools.main_frame,"CENTER",0,50)
                    MethodDungeonTools.main_frame.ExportFrameEditbox:SetText(export)
                    MethodDungeonTools.main_frame.ExportFrameEditbox:HighlightText(0, slen(export))
                    MethodDungeonTools.main_frame.ExportFrameEditbox:SetFocus()
                end,
            },
        }
        for buttonIdx,buttonData in ipairs(buttons) do
            local button = AceGUI:Create("Button")
            button:SetText(buttonData.text)
            button:SetCallback("OnClick",buttonData.func)
            container:AddChild(button)
        end
    end

    -- function that draws the widgets for the second tab
    local function DrawGroup2(container)
        local editBoxes = {}
        local countSlider
        local scaleSlider
        local dropdown

        local function updateFields(health,level,creatureType,id,scale,count,idx)
            if idx then
                local data = MethodDungeonTools.dungeonEnemies[db.currentDungeonIdx][idx]
                if not data then return end
                health = data.health
                level = data.level
                creatureType = data.creatureType
                id = data.id
                scale = data.scale
                count = data.count
            end
            editBoxes[1]:SetText(id)
            editBoxes[2]:SetText(health)
            editBoxes[3]:SetText(level)
            editBoxes[4]:SetText(creatureType)
            scaleSlider:SetValue(scale)
            countSlider:SetValue(count)
        end
        local function updateDropdown(npcId,idx)
            if not MethodDungeonTools.dungeonEnemies[db.currentDungeonIdx] then return end
            idx = idx or 1
            local enemies = {}
            for mobIdx,data in ipairs(MethodDungeonTools.dungeonEnemies[db.currentDungeonIdx]) do
                tinsert(enemies,mobIdx,data.name)
                if npcId then
                    if data.id == npcId then idx = mobIdx end
                end
            end
            dropdown:SetList(enemies)
            dropdown:SetValue(idx)
            currentEnemyIdx = idx
            updateFields(nil,nil,nil,nil,nil,nil,idx)
        end

        dropdown = AceGUI:Create("Dropdown")
        dropdown:SetCallback("OnValueChanged", function(widget,callbackName,key)
            currentEnemyIdx = key
            updateFields(nil,nil,nil,nil,nil,nil,key)
            local dungeonEnemyBlips = MethodDungeonTools:GetDungeonEnemyBlips()
            for _,v in ipairs(dungeonEnemyBlips) do
                v.devSelected = nil
            end
            MethodDungeonTools:UpdateMap()
        end)

        container:AddChild(dropdown)

        countSlider = AceGUI:Create("Slider")
        countSlider:SetLabel("Count")
        countSlider:SetSliderValues(0,15,1)
        countSlider:SetValue(4)
        countSlider:SetCallback("OnMouseUp",function(widget,callbackName,value)
            local count = tonumber(value)
            local npcIdx = tonumber(dropdown:GetValue())

            local data = MethodDungeonTools.dungeonEnemies[db.currentDungeonIdx][npcIdx]
            data["count"] = value
            MethodDungeonTools:UpdateMap()
        end)
        container:AddChild(countSlider)
        local fields = {
            [1] = "id",
            [2] = "health",
            [3] = "level",
            [4] = "creatureType",
        }
        for idx,name in ipairs(fields) do
            editBoxes[idx] = AceGUI:Create("EditBox")
            editBoxes[idx]:SetLabel(name)
            editBoxes[idx]:SetCallback("OnEnterPressed",function(widget,callbackName,text)
                local value = text
                if name ~= "creatureType" then
                    value = tonumber(text)
                end
                local npcIdx = dropdown:GetValue()
                local data = MethodDungeonTools.dungeonEnemies[db.currentDungeonIdx][npcIdx]
                data[name] = value
                MethodDungeonTools:UpdateMap()
            end)
            container:AddChild(editBoxes[idx])
        end

        scaleSlider = AceGUI:Create("Slider")
        scaleSlider:SetLabel("Scale")
        scaleSlider:SetSliderValues(0,5,0.1)
        scaleSlider:SetValue(1)
        scaleSlider:SetCallback("OnMouseUp",function(widget,callbackName,value)
            local npcIdx = tonumber(dropdown:GetValue())
            local data = MethodDungeonTools.dungeonEnemies[db.currentDungeonIdx][npcIdx]
            data["scale"] = value
            MethodDungeonTools:UpdateMap()
        end)
        container:AddChild(scaleSlider)

        local button1 = AceGUI:Create("Button")
        button1:SetText("Create from Target")
        button1:SetCallback("OnClick",function()
            local npcId
            local guid = UnitGUID("target")
            if guid then
                npcId = select(6,strsplit("-", guid))
            end
            if npcId then
                local npcName = UnitName("target")
                local npcHealth = UnitHealthMax("target")
                local npcLevel = UnitLevel("target")
                local npcCreatureType = UnitCreatureType("target")
                local npcScale = 1
                local npcCount = 0
                tinsert(MethodDungeonTools.dungeonEnemies[db.currentDungeonIdx], {
                    name = npcName,
                    health = npcHealth,
                    level = npcLevel,
                    creatureType = npcCreatureType,
                    id = npcId,
                    scale = npcScale,
                    count = npcCount,
                    clones = {},
                })
                --updateFields(npcHealth,npcLevel,npcCreatureType,npcId,npcScale,npcCount)
                updateDropdown(npcId)
            end

        end)
        container:AddChild(button1)

        --clone options
        local cloneGroup = AceGUI:Create("EditBox")
        cloneGroup:SetLabel("Group of clone:")
        cloneGroup:SetCallback("OnEnterPressed",function(widget,callbackName,text)
            local value = tonumber(text)
            if value and value>0 then currentCloneGroup = value else currentCloneGroup = nil end
            local currentBlip = MethodDungeonTools:GetCurrentDevmodeBlip()
            if currentBlip then
                cloneGroup:SetText(currentBlip.g)
                local data = MethodDungeonTools.dungeonEnemies[db.currentDungeonIdx][currentBlip.enemyIdx]
                data.clones[currentBlip.cloneIdx].g = currentCloneGroup
                MethodDungeonTools:UpdateMap()
            end
        end)

        container:AddChild(cloneGroup)

        local teemingCheckbox = AceGUI:Create("CheckBox")
        teemingCheckbox:SetLabel("Teeming")
        teemingCheckbox:SetCallback("OnValueChanged",function(widget,callbackName,value)
            currentTeeming = value and true or nil
            local currentBlip = MethodDungeonTools:GetCurrentDevmodeBlip()
            if currentBlip then
                local data = MethodDungeonTools.dungeonEnemies[db.currentDungeonIdx][currentBlip.enemyIdx]
                data.clones[currentBlip.cloneIdx].teeming = currentTeeming
                MethodDungeonTools:UpdateMap()
            end
        end)
        teemingCheckbox:SetValue(currentTeeming)
        container:AddChild(teemingCheckbox)

        --patrol sliders
        local pi = math.pi
        local patrolSlider1 = AceGUI:Create("Slider")
        patrolSlider1:SetLabel("Patrol Facing 1")
        patrolSlider1:SetSliderValues(0,2*pi,1/16)
        patrolSlider1.hightext:SetText("2pi")
        patrolSlider1:SetValue(currentPatrolfacing1 or 0)
        patrolSlider1:SetDisabled(not currentPatrol)
        patrolSlider1:SetCallback("OnMouseUp",function(widget,callbackName,value)
            local currentBlip = MethodDungeonTools:GetCurrentDevmodeBlip()
            if currentBlip then
                local data = MethodDungeonTools.dungeonEnemies[db.currentDungeonIdx][currentBlip.enemyIdx]
                currentPatrolfacing1 = value ~= 0 and value or nil
                data.clones[currentBlip.cloneIdx].patrolFacing = currentPatrolfacing1 or 0
                MethodDungeonTools:UpdateMap()
            end
        end)

        local patrolSlider2 = AceGUI:Create("Slider")
        patrolSlider2:SetLabel("Patrol Facing 2")
        patrolSlider2:SetSliderValues(0,2*pi,1/16)
        patrolSlider2.hightext:SetText("2pi")
        patrolSlider2:SetValue(currentPatrolfacing2 or 0)
        patrolSlider2:SetDisabled(not currentPatrol)
        patrolSlider2:SetCallback("OnMouseUp",function(widget,callbackName,value)
            local currentBlip = MethodDungeonTools:GetCurrentDevmodeBlip()
            if currentBlip then
                local data = MethodDungeonTools.dungeonEnemies[db.currentDungeonIdx][currentBlip.enemyIdx]
                currentPatrolfacing2 = value ~= 0 and value or nil
                data.clones[currentBlip.cloneIdx].patrolFacing2 = currentPatrolfacing2 or 0
                MethodDungeonTools:UpdateMap()
            end
        end)

        --patrol
        local patrolCheckbox = AceGUI:Create("CheckBox")
        patrolCheckbox:SetLabel("Patrol")
        patrolCheckbox:SetCallback("OnValueChanged",function(widget,callbackName,value)
            currentPatrol = value or nil
            patrolSlider1:SetDisabled(not currentPatrol)
            local currentBlip = MethodDungeonTools:GetCurrentDevmodeBlip()
            if currentBlip then
                local data = MethodDungeonTools.dungeonEnemies[db.currentDungeonIdx][currentBlip.enemyIdx]
                data.clones[currentBlip.cloneIdx].patrol = currentPatrol and (data.clones[currentBlip.cloneIdx].patrol or {}) or nil
                if not data.clones[currentBlip.cloneIdx].patrol then
                    data.clones[currentBlip.cloneIdx].patrolFacing = nil
                    data.clones[currentBlip.cloneIdx].patrolFacing2 = nil
                    currentBlip.patrolActive = false
                    currentBlip.patrolIndicator2.active = false
                end
                MethodDungeonTools:ShowBlipPatrol(currentBlip,false)
                MethodDungeonTools:UpdateMap()
            end
        end)
        container:AddChild(patrolCheckbox)
        container:AddChild(patrolSlider1)
        container:AddChild(patrolSlider2)

        --enter clone options into the GUI (red)
        local currentBlip = MethodDungeonTools:GetCurrentDevmodeBlip()
        if currentBlip then
            cloneGroup:SetText(currentBlip.g)
            teemingCheckbox:SetValue(currentBlip.teeming)
            currentTeeming = currentBlip.teeming
            currentPatrol = currentBlip.patrol and true or nil
            patrolCheckbox:SetValue(currentPatrol and currentBlip.patrolActive)
            patrolSlider1:SetDisabled(not (currentPatrol and currentBlip.patrolActive))
            currentPatrolfacing1 = currentBlip.patrolIndicator and currentBlip.patrolIndicator:GetRotation() or 0
            patrolSlider1:SetValue(currentPatrolfacing1)
            patrolSlider2:SetDisabled(not (currentPatrol and currentBlip.patrolActive))
            currentPatrolfacing2 = currentBlip.patrolIndicator2 and currentBlip.patrolIndicator2:GetRotation() or 0
            patrolSlider2:SetValue(currentPatrolfacing2)
        end

        local button2 = AceGUI:Create("Button")
        button2:SetText("Export to LUA")
        button2:SetCallback("OnClick",function()
            local export = tshow(MethodDungeonTools.dungeonEnemies[db.currentDungeonIdx],"MethodDungeonTools.dungeonEnemies[dungeonIndex]")
            MethodDungeonTools.main_frame.ExportFrame:Show()
            MethodDungeonTools.main_frame.ExportFrame:SetPoint("CENTER",MethodDungeonTools.main_frame,"CENTER",0,50)
            MethodDungeonTools.main_frame.ExportFrameEditbox:SetText(export)
            MethodDungeonTools.main_frame.ExportFrameEditbox:HighlightText(0, slen(export))
            MethodDungeonTools.main_frame.ExportFrameEditbox:SetFocus()
        end)
        container:AddChild(button2)





        updateDropdown(nil,currentEnemyIdx)
    end

    -- Callback function for OnGroupSelected
    local function SelectGroup(container, event, group)
        container:ReleaseChildren()
        if group == "tab1" then
            DrawGroup1(container)
        elseif group == "tab2" then
            DrawGroup2(container)
        end
    end
    devPanel:SetCallback("OnGroupSelected", SelectGroup)
    devPanel:SelectTab("tab2")

    --hook UpdateMap
    local originalFunc = MethodDungeonTools.UpdateMap
    function MethodDungeonTools:UpdateMap(...)
        originalFunc(...)
        local selectedTab
        for k,v in pairs(devPanel.tabs) do
            if v.selected == true then selectedTab = v.value; break end
        end
        --currentEnemyIdx
        local currentBlip = MethodDungeonTools:GetCurrentDevmodeBlip()
        if currentBlip then
            currentEnemyIdx=currentBlip.enemyIdx
        end
        devPanel:SelectTab(selectedTab)
        --show patrol
        local dungeonEnemyBlips = MethodDungeonTools:GetDungeonEnemyBlips()
        for _,v in ipairs(dungeonEnemyBlips) do
            MethodDungeonTools:ShowBlipPatrol(v,v.devSelected)
        end
    end


end



---AddCloneAtCursorPosition
---Adds a clone at the cursor position to the dungeon enemy table
---bound to hotkey and used to add new npcs to the map
function MethodDungeonTools:AddCloneAtCursorPosition()
    if not MouseIsOver(MethodDungeonToolsScrollFrame) then return end
    if currentEnemyIdx then
        local data = MethodDungeonTools.dungeonEnemies[db.currentDungeonIdx][currentEnemyIdx]
        local cursorx,cursory = MethodDungeonTools:GetCursorPosition()
        tinsert(data.clones,{x=cursorx,y=cursory,sublevel=MethodDungeonTools:GetCurrentSubLevel(),g=currentCloneGroup,teeming=currentTeeming})
        print(string.format("MDT: Created clone %s %d at %d,%d",data.name,#data.clones,cursorx,cursory))
        MethodDungeonTools:UpdateMap()
        MethodDungeonTools:SetCurrentDevmodeBlip(currentEnemyIdx,#data.clones)
    end
end

---AddPatrolWaypointAtCursorPosition

function MethodDungeonTools:AddPatrolWaypointAtCursorPosition()
    if not MouseIsOver(MethodDungeonToolsScrollFrame) then return end
    local currentBlip = MethodDungeonTools:GetCurrentDevmodeBlip()
    if currentBlip then
        local data = MethodDungeonTools.dungeonEnemies[db.currentDungeonIdx][currentBlip.enemyIdx]
        local cloneData = data.clones[currentBlip.cloneIdx]
        cloneData.patrol = cloneData.patrol or {}
        cloneData.patrol[1] = {x=cloneData.x,y=cloneData.y}
        local cursorx,cursory = MethodDungeonTools:GetCursorPosition()
        --snap onto other waypoints
        local dungeonEnemyBlips = MethodDungeonTools:GetDungeonEnemyBlips()
        for blipIdx,blip in pairs(dungeonEnemyBlips) do
            if blip.patrol then
                for idx,waypoint in pairs(blip.patrol) do
                    if MouseIsOver(waypoint) then
                        cursorx = waypoint.x
                        cursory = waypoint.y
                    end
                end
            end
        end
        tinsert(cloneData.patrol,{x=cursorx,y=cursory})
        print(string.format("MDT: Created Waypoint %d of %s %d at %d,%d",1,data.name,#cloneData.patrol,cursorx,cursory))
        MethodDungeonTools:UpdateMap()
    end
end